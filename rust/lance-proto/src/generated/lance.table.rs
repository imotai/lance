// This file is @generated by prost-build.
/// / UUID type. encoded as 16 bytes.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Uuid {
    #[prost(bytes = "vec", tag = "1")]
    pub uuid: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for Uuid {
    const NAME: &'static str = "UUID";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.UUID".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.UUID".into()
    }
}
/// Manifest is a global section shared between all the files.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Manifest {
    /// All fields of the dataset, including the nested fields.
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<crate::pb::Field>,
    /// Fragments of the dataset.
    #[prost(message, repeated, tag = "2")]
    pub fragments: ::prost::alloc::vec::Vec<DataFragment>,
    /// Snapshot version number.
    #[prost(uint64, tag = "3")]
    pub version: u64,
    /// The file position of the version auxiliary data.
    ///   * It is not inheritable between versions.
    ///   * It is not loaded by default during query.
    #[prost(uint64, tag = "4")]
    pub version_aux_data: u64,
    /// Schema metadata.
    #[prost(map = "string, bytes", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// The version of the writer that created this file.
    ///
    /// This information may be used to detect whether the file may have known bugs
    /// associated with that writer.
    #[prost(message, optional, tag = "13")]
    pub writer_version: ::core::option::Option<manifest::WriterVersion>,
    /// If presented, the file position of the index metadata.
    #[prost(uint64, optional, tag = "6")]
    pub index_section: ::core::option::Option<u64>,
    /// Version creation Timestamp, UTC timezone
    #[prost(message, optional, tag = "7")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Optional version tag
    #[prost(string, tag = "8")]
    pub tag: ::prost::alloc::string::String,
    /// Feature flags for readers.
    ///
    /// A bitmap of flags that indicate which features are required to be able to
    /// read the table. If a reader does not recognize a flag that is set, it
    /// should not attempt to read the dataset.
    ///
    /// Known flags:
    /// * 1: deletion files are present
    /// * 2: move_stable_row_ids: row IDs are tracked and stable after move operations
    ///        (such as compaction), but not updates.
    /// * 4: use v2 format (deprecated)
    /// * 8: table config is present
    #[prost(uint64, tag = "9")]
    pub reader_feature_flags: u64,
    /// Feature flags for writers.
    ///
    /// A bitmap of flags that indicate which features are required to be able to
    /// write to the dataset. if a writer does not recognize a flag that is set, it
    /// should not attempt to write to the dataset.
    ///
    /// The flags are the same as for reader_feature_flags, although they will not
    /// always apply to both.
    #[prost(uint64, tag = "10")]
    pub writer_feature_flags: u64,
    /// The highest fragment ID that has been used so far.
    ///
    /// This ID is not guaranteed to be present in the current version, but it may
    /// have been used in previous versions.
    ///
    /// For a single file, will be zero.
    #[prost(uint32, tag = "11")]
    pub max_fragment_id: u32,
    /// Path to the transaction file, relative to `{root}/_transactions`
    ///
    /// This contains a serialized Transaction message representing the transaction
    /// that created this version.
    ///
    /// May be empty if no transaction file was written.
    ///
    /// The path format is "{read_version}-{uuid}.txn" where {read_version} is the
    /// version of the table the transaction read from, and {uuid} is a
    /// hyphen-separated UUID.
    #[prost(string, tag = "12")]
    pub transaction_file: ::prost::alloc::string::String,
    /// The next unused row id. If zero, then the table does not have any rows.
    ///
    /// This is only used if the "move_stable_row_ids" feature flag is set.
    #[prost(uint64, tag = "14")]
    pub next_row_id: u64,
    /// The data storage format
    ///
    /// This specifies what format is used to store the data files.
    #[prost(message, optional, tag = "15")]
    pub data_format: ::core::option::Option<manifest::DataStorageFormat>,
    /// Table config.
    ///
    /// Keys with the prefix "lance." are reserved for the Lance library. Other
    /// libraries may wish to similarly prefix their configuration keys
    /// appropriately.
    #[prost(map = "string, string", tag = "16")]
    pub config: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
/// Nested message and enum types in `Manifest`.
pub mod manifest {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct WriterVersion {
        /// The name of the library that created this file.
        #[prost(string, tag = "1")]
        pub library: ::prost::alloc::string::String,
        /// The version of the library that created this file. Because we cannot assume
        /// that the library is semantically versioned, this is a string. However, if it
        /// is semantically versioned, it should be a valid semver string without any 'v'
        /// prefix. For example: `2.0.0`, `2.0.0-rc.1`.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
    }
    impl ::prost::Name for WriterVersion {
        const NAME: &'static str = "WriterVersion";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Manifest.WriterVersion".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Manifest.WriterVersion".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct DataStorageFormat {
        /// The format of the data files (e.g. "lance")
        #[prost(string, tag = "1")]
        pub file_format: ::prost::alloc::string::String,
        /// The max format version of the data files.
        ///
        /// This is the maximum version of the file format that the dataset will create.
        /// This may be lower than the maximum version that can be written in order to allow
        /// older readers to read the dataset.
        #[prost(string, tag = "2")]
        pub version: ::prost::alloc::string::String,
    }
    impl ::prost::Name for DataStorageFormat {
        const NAME: &'static str = "DataStorageFormat";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Manifest.DataStorageFormat".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Manifest.DataStorageFormat".into()
        }
    }
}
impl ::prost::Name for Manifest {
    const NAME: &'static str = "Manifest";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.Manifest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.Manifest".into()
    }
}
/// Auxiliary Data attached to a version.
/// Only load on-demand.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VersionAuxData {
    /// key-value metadata.
    #[prost(map = "string, bytes", tag = "3")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
impl ::prost::Name for VersionAuxData {
    const NAME: &'static str = "VersionAuxData";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.VersionAuxData".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.VersionAuxData".into()
    }
}
/// Metadata describing the index.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexMetadata {
    /// Unique ID of an index. It is unique across all the dataset versions.
    #[prost(message, optional, tag = "1")]
    pub uuid: ::core::option::Option<Uuid>,
    /// The columns to build the index.
    #[prost(int32, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<i32>,
    /// Index name. Must be unique within one dataset version.
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// The version of the dataset this index was built from.
    #[prost(uint64, tag = "4")]
    pub dataset_version: u64,
    /// / A bitmap of the included fragment ids.
    /// /
    /// / This may by used to determine how much of the dataset is covered by the
    /// / index. This information can be retrieved from the dataset by looking at
    /// / the dataset at `dataset_version`. However, since the old version may be
    /// / deleted while the index is still in use, this information is also stored
    /// / in the index.
    /// /
    /// / The bitmap is stored as a 32-bit Roaring bitmap.
    #[prost(bytes = "vec", tag = "5")]
    pub fragment_bitmap: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for IndexMetadata {
    const NAME: &'static str = "IndexMetadata";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.IndexMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.IndexMetadata".into()
    }
}
/// Index Section, containing a list of index metadata for one dataset version.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexSection {
    #[prost(message, repeated, tag = "1")]
    pub indices: ::prost::alloc::vec::Vec<IndexMetadata>,
}
impl ::prost::Name for IndexSection {
    const NAME: &'static str = "IndexSection";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.IndexSection".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.IndexSection".into()
    }
}
/// Data fragment. A fragment is a set of files which represent the
/// different columns of the same rows.
/// If column exists in the schema, but the related file does not exist,
/// treat this column as nulls.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataFragment {
    /// Unique ID of each DataFragment
    #[prost(uint64, tag = "1")]
    pub id: u64,
    #[prost(message, repeated, tag = "2")]
    pub files: ::prost::alloc::vec::Vec<DataFile>,
    /// File that indicates which rows, if any, should be considered deleted.
    #[prost(message, optional, tag = "3")]
    pub deletion_file: ::core::option::Option<DeletionFile>,
    /// Number of original rows in the fragment, this includes rows that are
    /// now marked with deletion tombstones. To compute the current number of rows,
    /// subtract `deletion_file.num_deleted_rows` from this value.
    #[prost(uint64, tag = "4")]
    pub physical_rows: u64,
    /// A serialized RowIdSequence message (see rowids.proto).
    ///
    /// These are the row ids for the fragment, in order of the rows as they appear.
    /// That is, if a fragment has 3 rows, and the row ids are \[1, 42, 3\], then the
    /// first row is row 1, the second row is row 42, and the third row is row 3.
    #[prost(oneof = "data_fragment::RowIdSequence", tags = "5, 6")]
    pub row_id_sequence: ::core::option::Option<data_fragment::RowIdSequence>,
}
/// Nested message and enum types in `DataFragment`.
pub mod data_fragment {
    /// A serialized RowIdSequence message (see rowids.proto).
    ///
    /// These are the row ids for the fragment, in order of the rows as they appear.
    /// That is, if a fragment has 3 rows, and the row ids are \[1, 42, 3\], then the
    /// first row is row 1, the second row is row 42, and the third row is row 3.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RowIdSequence {
        /// If small (< 200KB), the row ids are stored inline.
        #[prost(bytes, tag = "5")]
        InlineRowIds(::prost::alloc::vec::Vec<u8>),
        /// Otherwise, stored as part of a file.
        #[prost(message, tag = "6")]
        ExternalRowIds(super::ExternalFile),
    }
}
impl ::prost::Name for DataFragment {
    const NAME: &'static str = "DataFragment";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.DataFragment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.DataFragment".into()
    }
}
/// Lance Data File
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DataFile {
    /// Relative path to the root.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// The ids of the fields/columns in this file.
    ///
    /// -1 is used for "unassigned" while in memory. It is not meant to be written
    /// to disk. -2 is used for "tombstoned", meaningful a field that is no longer
    /// in use. This is often because the original field id was reassigned to a
    /// different data file.
    ///
    /// In Lance v1 IDs are assigned based on position in the file, offset by the max
    /// existing field id in the table (if any already). So when a fragment is first
    /// created with one file of N columns, the field ids will be 1, 2, ..., N. If a
    /// second, fragment is created with M columns, the field ids will be N+1, N+2,
    /// ..., N+M.
    ///
    /// In Lance v1 there is one field for each field in the input schema, this includes
    /// nested fields (both struct and list).  Fixed size list fields have only a single
    /// field id (these are not considered nested fields in Lance v1).
    ///
    /// This allows column indices to be calculated from field IDs and the input schema.
    ///
    /// In Lance v2 the field IDs generally follow the same pattern but there is no
    /// way to calculate the column index from the field ID.  This is because a given
    /// field could be encoded in many different ways, some of which occupy a different
    /// number of columns.  For example, a struct field could be encoded into N + 1 columns
    /// or it could be encoded into a single packed column.  To determine column indices
    /// the column_indices property should be used instead.
    ///
    /// In Lance v1 these ids must be sorted but might not always be contiguous.
    #[prost(int32, repeated, tag = "2")]
    pub fields: ::prost::alloc::vec::Vec<i32>,
    /// The top-level column indices for each field in the file.
    ///
    /// If the data file is version 1 then this property will be empty
    ///
    /// Otherwise there must be one entry for each field in `fields`.
    ///
    /// Some fields may not correspond to a top-level column in the file.  In these cases
    /// the index will -1.
    ///
    /// For example, consider the schema:
    ///
    /// - dimension: packed-struct (0):
    ///    - x: u32 (1)
    ///    - y: u32 (2)
    /// - path: list<u32> (3)
    /// - embedding: fsl<768> (4)
    ///    - fp64
    /// - borders: fsl<4> (5)
    ///    - simple-struct (6)
    ///      - margin: fp64 (7)
    ///      - padding: fp64 (8)
    ///
    /// One possible column indices array could be:
    /// \[0, -1, -1, 1, 3, 4, 5, 6, 7\]
    ///
    /// This reflects quite a few phenomenon:
    /// - The packed struct is encoded into a single column and there is no top-level column
    ///    for the x or y fields
    /// - The variable sized list is encoded into two columns
    /// - The embedding is encoded into a single column (common for FSL of primitive) and there
    ///    is not "FSL column"
    /// - The borders field actually does have an "FSL column"
    ///
    /// The column indices table may not have duplicates (other than -1)
    #[prost(int32, repeated, tag = "3")]
    pub column_indices: ::prost::alloc::vec::Vec<i32>,
    /// The major file version used to create the file
    #[prost(uint32, tag = "4")]
    pub file_major_version: u32,
    /// The minor file version used to create the file
    ///
    /// If both `file_major_version` and `file_minor_version` are set to 0,
    /// then this is a version 0.1 or version 0.2 file.
    #[prost(uint32, tag = "5")]
    pub file_minor_version: u32,
}
impl ::prost::Name for DataFile {
    const NAME: &'static str = "DataFile";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.DataFile".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.DataFile".into()
    }
}
/// Deletion File
///
/// The path of the deletion file is constructed as:
///    {root}/_deletions/{fragment_id}-{read_version}-{id}.{extension}
/// where {extension} is `.arrow` or `.bin` depending on the type of deletion.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeletionFile {
    /// Type of deletion file. If it is unspecified, then the remaining fields will be missing.
    #[prost(enumeration = "deletion_file::DeletionFileType", tag = "1")]
    pub file_type: i32,
    /// The version of the dataset this deletion file was built from.
    #[prost(uint64, tag = "2")]
    pub read_version: u64,
    /// An opaque id used to differentiate this file from others written by concurrent
    /// writers.
    #[prost(uint64, tag = "3")]
    pub id: u64,
    /// The number of rows that are marked as deleted.
    #[prost(uint64, tag = "4")]
    pub num_deleted_rows: u64,
}
/// Nested message and enum types in `DeletionFile`.
pub mod deletion_file {
    /// Type of deletion file, which varies depending on what is the most efficient
    /// way to store the deleted row offsets. If none, then will be unspecified. If there are
    /// sparsely deleted rows, then ARROW_ARRAY is the most efficient. If there are
    /// densely deleted rows, then BIT_MAP is the most efficient.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DeletionFileType {
        /// Deletion file is a single Int32Array of deleted row offsets. This is stored as
        /// an Arrow IPC file with one batch and one column. Has a .arrow extension.
        ArrowArray = 0,
        /// Deletion file is a Roaring Bitmap of deleted row offsets. Has a .bin extension.
        Bitmap = 1,
    }
    impl DeletionFileType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DeletionFileType::ArrowArray => "ARROW_ARRAY",
                DeletionFileType::Bitmap => "BITMAP",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "ARROW_ARRAY" => Some(Self::ArrowArray),
                "BITMAP" => Some(Self::Bitmap),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for DeletionFile {
    const NAME: &'static str = "DeletionFile";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.DeletionFile".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.DeletionFile".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalFile {
    /// Path to the file, relative to the root of the table.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// The offset in the file where the data starts.
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    /// The size of the data in the file.
    #[prost(uint64, tag = "3")]
    pub size: u64,
}
impl ::prost::Name for ExternalFile {
    const NAME: &'static str = "ExternalFile";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.ExternalFile".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.ExternalFile".into()
    }
}
/// A transaction represents the changes to a dataset.
///
/// This has two purposes:
/// 1. When retrying a commit, the transaction can be used to re-build an updated
///     manifest.
/// 2. When there's a conflict, this can be used to determine whether the other
///     transaction is compatible with this one.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transaction {
    /// The version of the dataset this transaction was built from.
    ///
    /// For example, for a delete transaction this means the version of the dataset
    /// that was read from while evaluating the deletion predicate.
    #[prost(uint64, tag = "1")]
    pub read_version: u64,
    /// The UUID that unique identifies a transaction.
    #[prost(string, tag = "2")]
    pub uuid: ::prost::alloc::string::String,
    /// Optional version tag.
    #[prost(string, tag = "3")]
    pub tag: ::prost::alloc::string::String,
    /// The operation of this transaction.
    #[prost(
        oneof = "transaction::Operation",
        tags = "100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110"
    )]
    pub operation: ::core::option::Option<transaction::Operation>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    /// Add new rows to the dataset.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Append {
        /// The new fragments to append.
        ///
        /// Fragment IDs are not yet assigned.
        #[prost(message, repeated, tag = "1")]
        pub fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
    }
    impl ::prost::Name for Append {
        const NAME: &'static str = "Append";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Append".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Append".into()
        }
    }
    /// Mark rows as deleted.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Delete {
        /// The fragments to update
        ///
        /// The fragment IDs will match existing fragments in the dataset.
        #[prost(message, repeated, tag = "1")]
        pub updated_fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
        /// The fragments to delete entirely.
        #[prost(uint64, repeated, tag = "2")]
        pub deleted_fragment_ids: ::prost::alloc::vec::Vec<u64>,
        /// The predicate that was evaluated
        ///
        /// This may be used to determine whether the delete would have affected
        /// files written by a concurrent transaction.
        #[prost(string, tag = "3")]
        pub predicate: ::prost::alloc::string::String,
    }
    impl ::prost::Name for Delete {
        const NAME: &'static str = "Delete";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Delete".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Delete".into()
        }
    }
    /// Create or overwrite the entire dataset.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Overwrite {
        /// The new fragments
        ///
        /// Fragment IDs are not yet assigned.
        #[prost(message, repeated, tag = "1")]
        pub fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
        /// The new schema
        #[prost(message, repeated, tag = "2")]
        pub schema: ::prost::alloc::vec::Vec<crate::pb::Field>,
        /// Schema metadata.
        #[prost(map = "string, bytes", tag = "3")]
        pub schema_metadata: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::vec::Vec<u8>,
        >,
        /// Key-value pairs to merge with existing config.
        #[prost(map = "string, string", tag = "4")]
        pub config_upsert_values: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
    }
    impl ::prost::Name for Overwrite {
        const NAME: &'static str = "Overwrite";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Overwrite".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Overwrite".into()
        }
    }
    /// Add or replace a new secondary index.
    ///
    /// - new_indices: the modified indices
    /// - removed_indices: the indices that are being replaced
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct CreateIndex {
        #[prost(message, repeated, tag = "1")]
        pub new_indices: ::prost::alloc::vec::Vec<super::IndexMetadata>,
        #[prost(message, repeated, tag = "2")]
        pub removed_indices: ::prost::alloc::vec::Vec<super::IndexMetadata>,
    }
    impl ::prost::Name for CreateIndex {
        const NAME: &'static str = "CreateIndex";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.CreateIndex".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.CreateIndex".into()
        }
    }
    /// An operation that rewrites but does not change the data in the table. These
    /// kinds of operations just rearrange data.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Rewrite {
        /// The old fragments that are being replaced
        ///
        /// DEPRECATED: use groups instead.
        ///
        /// These should all have existing fragment IDs.
        #[prost(message, repeated, tag = "1")]
        pub old_fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
        /// The new fragments
        ///
        /// DEPRECATED: use groups instead.
        ///
        /// These fragments IDs are not yet assigned.
        #[prost(message, repeated, tag = "2")]
        pub new_fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
        /// Groups of files that have been rewritten
        #[prost(message, repeated, tag = "3")]
        pub groups: ::prost::alloc::vec::Vec<rewrite::RewriteGroup>,
        /// Indices that have been rewritten
        #[prost(message, repeated, tag = "4")]
        pub rewritten_indices: ::prost::alloc::vec::Vec<rewrite::RewrittenIndex>,
    }
    /// Nested message and enum types in `Rewrite`.
    pub mod rewrite {
        /// During a rewrite an index may be rewritten.  We only serialize the UUID
        /// since a rewrite should not change the other index parameters.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RewrittenIndex {
            /// The id of the index that will be replaced
            #[prost(message, optional, tag = "1")]
            pub old_id: ::core::option::Option<super::super::Uuid>,
            /// the id of the new index
            #[prost(message, optional, tag = "2")]
            pub new_id: ::core::option::Option<super::super::Uuid>,
        }
        impl ::prost::Name for RewrittenIndex {
            const NAME: &'static str = "RewrittenIndex";
            const PACKAGE: &'static str = "lance.table";
            fn full_name() -> ::prost::alloc::string::String {
                "lance.table.Transaction.Rewrite.RewrittenIndex".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/lance.table.Transaction.Rewrite.RewrittenIndex".into()
            }
        }
        /// A group of rewrite files that are all part of the same rewrite.
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RewriteGroup {
            /// The old fragment that is being replaced
            ///
            /// This should have an existing fragment ID.
            #[prost(message, repeated, tag = "1")]
            pub old_fragments: ::prost::alloc::vec::Vec<super::super::DataFragment>,
            /// The new fragment
            ///
            /// The ID should have been reserved by an earlier
            /// reserve operation
            #[prost(message, repeated, tag = "2")]
            pub new_fragments: ::prost::alloc::vec::Vec<super::super::DataFragment>,
        }
        impl ::prost::Name for RewriteGroup {
            const NAME: &'static str = "RewriteGroup";
            const PACKAGE: &'static str = "lance.table";
            fn full_name() -> ::prost::alloc::string::String {
                "lance.table.Transaction.Rewrite.RewriteGroup".into()
            }
            fn type_url() -> ::prost::alloc::string::String {
                "/lance.table.Transaction.Rewrite.RewriteGroup".into()
            }
        }
    }
    impl ::prost::Name for Rewrite {
        const NAME: &'static str = "Rewrite";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Rewrite".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Rewrite".into()
        }
    }
    /// An operation that merges in a new column, altering the schema.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Merge {
        /// The updated fragments
        ///
        /// These should all have existing fragment IDs.
        #[prost(message, repeated, tag = "1")]
        pub fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
        /// The new schema
        #[prost(message, repeated, tag = "2")]
        pub schema: ::prost::alloc::vec::Vec<crate::pb::Field>,
        /// Schema metadata.
        #[prost(map = "string, bytes", tag = "3")]
        pub schema_metadata: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::vec::Vec<u8>,
        >,
    }
    impl ::prost::Name for Merge {
        const NAME: &'static str = "Merge";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Merge".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Merge".into()
        }
    }
    /// An operation that projects a subset of columns, altering the schema.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Project {
        /// The new schema
        #[prost(message, repeated, tag = "1")]
        pub schema: ::prost::alloc::vec::Vec<crate::pb::Field>,
    }
    impl ::prost::Name for Project {
        const NAME: &'static str = "Project";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Project".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Project".into()
        }
    }
    /// An operation that restores a dataset to a previous version.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Restore {
        /// The version to restore to
        #[prost(uint64, tag = "1")]
        pub version: u64,
    }
    impl ::prost::Name for Restore {
        const NAME: &'static str = "Restore";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Restore".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Restore".into()
        }
    }
    /// An operation that reserves fragment ids for future use in
    /// a rewrite operation.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct ReserveFragments {
        #[prost(uint32, tag = "1")]
        pub num_fragments: u32,
    }
    impl ::prost::Name for ReserveFragments {
        const NAME: &'static str = "ReserveFragments";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.ReserveFragments".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.ReserveFragments".into()
        }
    }
    /// An operation that updates rows but does not add or remove rows.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Update {
        /// The fragments that have been removed. These are fragments where all rows
        /// have been updated and moved to a new fragment.
        #[prost(uint64, repeated, tag = "1")]
        pub removed_fragment_ids: ::prost::alloc::vec::Vec<u64>,
        /// The fragments that have been updated.
        #[prost(message, repeated, tag = "2")]
        pub updated_fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
        /// The new fragments where updated rows have been moved to.
        #[prost(message, repeated, tag = "3")]
        pub new_fragments: ::prost::alloc::vec::Vec<super::DataFragment>,
    }
    impl ::prost::Name for Update {
        const NAME: &'static str = "Update";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.Update".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.Update".into()
        }
    }
    /// An operation that updates the table config.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct UpdateConfig {
        #[prost(map = "string, string", tag = "1")]
        pub upsert_values: ::std::collections::HashMap<
            ::prost::alloc::string::String,
            ::prost::alloc::string::String,
        >,
        #[prost(string, repeated, tag = "2")]
        pub delete_keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    }
    impl ::prost::Name for UpdateConfig {
        const NAME: &'static str = "UpdateConfig";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.Transaction.UpdateConfig".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.Transaction.UpdateConfig".into()
        }
    }
    /// The operation of this transaction.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Operation {
        #[prost(message, tag = "100")]
        Append(Append),
        #[prost(message, tag = "101")]
        Delete(Delete),
        #[prost(message, tag = "102")]
        Overwrite(Overwrite),
        #[prost(message, tag = "103")]
        CreateIndex(CreateIndex),
        #[prost(message, tag = "104")]
        Rewrite(Rewrite),
        #[prost(message, tag = "105")]
        Merge(Merge),
        #[prost(message, tag = "106")]
        Restore(Restore),
        #[prost(message, tag = "107")]
        ReserveFragments(ReserveFragments),
        #[prost(message, tag = "108")]
        Update(Update),
        #[prost(message, tag = "109")]
        Project(Project),
        #[prost(message, tag = "110")]
        UpdateConfig(UpdateConfig),
    }
}
impl ::prost::Name for Transaction {
    const NAME: &'static str = "Transaction";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.Transaction".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.Transaction".into()
    }
}
/// / A sequence of row IDs. This is split up into one or more segments,
/// / each of which can be encoded in different ways. The encodings are optimized
/// / for values that are sorted, which will often be the case with row ids.
/// / They also have optimized forms depending on how sparse the values are.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RowIdSequence {
    #[prost(message, repeated, tag = "1")]
    pub segments: ::prost::alloc::vec::Vec<U64Segment>,
}
impl ::prost::Name for RowIdSequence {
    const NAME: &'static str = "RowIdSequence";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.RowIdSequence".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.RowIdSequence".into()
    }
}
/// / Different ways to encode a sequence of u64 values.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct U64Segment {
    #[prost(oneof = "u64_segment::Segment", tags = "1, 2, 3, 4, 5")]
    pub segment: ::core::option::Option<u64_segment::Segment>,
}
/// Nested message and enum types in `U64Segment`.
pub mod u64_segment {
    /// / A range of u64 values.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Range {
        /// / The start of the range, inclusive.
        #[prost(uint64, tag = "1")]
        pub start: u64,
        /// / The end of the range, exclusive.
        #[prost(uint64, tag = "2")]
        pub end: u64,
    }
    impl ::prost::Name for Range {
        const NAME: &'static str = "Range";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.U64Segment.Range".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.U64Segment.Range".into()
        }
    }
    /// / A range of u64 values with holes.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeWithHoles {
        /// / The start of the range, inclusive.
        #[prost(uint64, tag = "1")]
        pub start: u64,
        /// / The end of the range, exclusive.
        #[prost(uint64, tag = "2")]
        pub end: u64,
        /// / The holes in the range, as a sorted array of values;
        /// / Binary search can be used to check whether a value is a hole and should
        /// / be skipped. This can also be used to count the number of holes before a
        /// / given value, if you need to find the logical offset of a value in the
        /// / segment.
        #[prost(message, optional, tag = "3")]
        pub holes: ::core::option::Option<super::EncodedU64Array>,
    }
    impl ::prost::Name for RangeWithHoles {
        const NAME: &'static str = "RangeWithHoles";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.U64Segment.RangeWithHoles".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.U64Segment.RangeWithHoles".into()
        }
    }
    /// / A range of u64 values with a bitmap.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeWithBitmap {
        /// / The start of the range, inclusive.
        #[prost(uint64, tag = "1")]
        pub start: u64,
        /// / The end of the range, exclusive.
        #[prost(uint64, tag = "2")]
        pub end: u64,
        /// / A bitmap of the values in the range. The bitmap is a sequence of bytes,
        /// / where each byte represents 8 values. The first byte represents values
        /// / start to start + 7, the second byte represents values start + 8 to
        /// / start + 15, and so on. The most significant bit of each byte represents
        /// / the first value in the range, and the least significant bit represents
        /// / the last value in the range. If the bit is set, the value is in the
        /// / range; if it is not set, the value is not in the range.
        #[prost(bytes = "vec", tag = "3")]
        pub bitmap: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for RangeWithBitmap {
        const NAME: &'static str = "RangeWithBitmap";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.U64Segment.RangeWithBitmap".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.U64Segment.RangeWithBitmap".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Segment {
        /// / When the values are sorted and contiguous.
        #[prost(message, tag = "1")]
        Range(Range),
        /// / When the values are sorted but have a few gaps.
        #[prost(message, tag = "2")]
        RangeWithHoles(RangeWithHoles),
        /// / When the values are sorted but have many gaps.
        #[prost(message, tag = "3")]
        RangeWithBitmap(RangeWithBitmap),
        /// / When the values are sorted but are sparse.
        #[prost(message, tag = "4")]
        SortedArray(super::EncodedU64Array),
        /// / A general array of values, which is not sorted.
        #[prost(message, tag = "5")]
        Array(super::EncodedU64Array),
    }
}
impl ::prost::Name for U64Segment {
    const NAME: &'static str = "U64Segment";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.U64Segment".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.U64Segment".into()
    }
}
/// / A basic bitpacked array of u64 values.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EncodedU64Array {
    #[prost(oneof = "encoded_u64_array::Array", tags = "1, 2, 3")]
    pub array: ::core::option::Option<encoded_u64_array::Array>,
}
/// Nested message and enum types in `EncodedU64Array`.
pub mod encoded_u64_array {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct U16Array {
        #[prost(uint64, tag = "1")]
        pub base: u64,
        /// / The deltas are stored as 16-bit unsigned integers.
        /// / (protobuf doesn't support 16-bit integers, so we use bytes instead)
        #[prost(bytes = "vec", tag = "2")]
        pub offsets: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for U16Array {
        const NAME: &'static str = "U16Array";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.EncodedU64Array.U16Array".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.EncodedU64Array.U16Array".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct U32Array {
        #[prost(uint64, tag = "1")]
        pub base: u64,
        /// / The deltas are stored as 32-bit unsigned integers.
        /// / (we use bytes instead of uint32 to avoid overhead of varint encoding)
        #[prost(bytes = "vec", tag = "2")]
        pub offsets: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for U32Array {
        const NAME: &'static str = "U32Array";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.EncodedU64Array.U32Array".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.EncodedU64Array.U32Array".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct U64Array {
        /// / (We use bytes instead of uint64 to avoid overhead of varint encoding)
        #[prost(bytes = "vec", tag = "2")]
        pub values: ::prost::alloc::vec::Vec<u8>,
    }
    impl ::prost::Name for U64Array {
        const NAME: &'static str = "U64Array";
        const PACKAGE: &'static str = "lance.table";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.table.EncodedU64Array.U64Array".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.table.EncodedU64Array.U64Array".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Array {
        #[prost(message, tag = "1")]
        U16Array(U16Array),
        #[prost(message, tag = "2")]
        U32Array(U32Array),
        #[prost(message, tag = "3")]
        U64Array(U64Array),
    }
}
impl ::prost::Name for EncodedU64Array {
    const NAME: &'static str = "EncodedU64Array";
    const PACKAGE: &'static str = "lance.table";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.table.EncodedU64Array".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.table.EncodedU64Array".into()
    }
}
