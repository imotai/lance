// This file is @generated by prost-build.
/// The deferred encoding is used to place the encoding itself in a different
/// part of the file.  This is most commonly used to allow encodings to be shared
/// across different columns.  For example, when writing a file with thousands of
/// columns, where many pages have the exact same encoding, it can be useful
/// to cut down on the size of the metadata by using a deferred encoding.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DeferredEncoding {
    /// Location of the buffer containing the encoding.
    ///
    /// * If sharing encodings across columns then this will be in a global buffer
    /// * If sharing encodings across pages within a column this could be in a
    ///    column metadata buffer.
    /// * This could also be a page buffer if the encoding is not shared, needs
    ///    to be written before the file ends, and the encoding is too large to load
    ///    unless we first determine the page needs to be read.  This combination
    ///    seems unusual.
    #[prost(uint64, tag = "1")]
    pub buffer_location: u64,
    #[prost(uint64, tag = "2")]
    pub buffer_length: u64,
}
impl ::prost::Name for DeferredEncoding {
    const NAME: &'static str = "DeferredEncoding";
    const PACKAGE: &'static str = "lance.file.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.v2.DeferredEncoding".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.v2.DeferredEncoding".into()
    }
}
/// The encoding is placed directly in the metadata section
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectEncoding {
    /// The bytes that make up the encoding embedded directly in the metadata
    ///
    /// This is the most common approach.
    #[prost(bytes = "vec", tag = "1")]
    pub encoding: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for DirectEncoding {
    const NAME: &'static str = "DirectEncoding";
    const PACKAGE: &'static str = "lance.file.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.v2.DirectEncoding".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.v2.DirectEncoding".into()
    }
}
/// An encoding stores the information needed to decode a column or page
///
/// For example, it could describe if the page is using bit packing, and how many bits
/// there are in each individual value.
///
/// At the column level it can be used to wrap columns with dictionaries or statistics.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Encoding {
    #[prost(oneof = "encoding::Location", tags = "1, 2, 3")]
    pub location: ::core::option::Option<encoding::Location>,
}
/// Nested message and enum types in `Encoding`.
pub mod encoding {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Location {
        /// The encoding is stored elsewhere and not part of this protobuf message
        #[prost(message, tag = "1")]
        Indirect(super::DeferredEncoding),
        /// The encoding is stored within this protobuf message
        #[prost(message, tag = "2")]
        Direct(super::DirectEncoding),
        /// There is no encoding information
        #[prost(message, tag = "3")]
        None(()),
    }
}
impl ::prost::Name for Encoding {
    const NAME: &'static str = "Encoding";
    const PACKAGE: &'static str = "lance.file.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.v2.Encoding".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.v2.Encoding".into()
    }
}
/// Each column has a metadata block that is placed at the end of the file.
/// These may be read individually to allow for column projection.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnMetadata {
    /// Encoding information about the column itself.  This typically describes
    /// how to interpret the column metadata buffers.  For example, it could
    /// describe how statistics or dictionaries are stored in the column metadata.
    #[prost(message, optional, tag = "1")]
    pub encoding: ::core::option::Option<Encoding>,
    /// The pages in the column
    #[prost(message, repeated, tag = "2")]
    pub pages: ::prost::alloc::vec::Vec<column_metadata::Page>,
    /// The file offsets of each of the column metadata buffers
    ///
    /// There may be zero buffers.
    #[prost(uint64, repeated, tag = "3")]
    pub buffer_offsets: ::prost::alloc::vec::Vec<u64>,
    /// The size (in bytes) of each of the column metadata buffers
    ///
    /// This field will have the same length as `buffer_offsets` and
    /// may be empty.
    #[prost(uint64, repeated, tag = "4")]
    pub buffer_sizes: ::prost::alloc::vec::Vec<u64>,
}
/// Nested message and enum types in `ColumnMetadata`.
pub mod column_metadata {
    /// This describes a page of column data.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Page {
        /// The file offsets for each of the page buffers
        ///
        /// The number of buffers is variable and depends on the encoding.  There
        /// may be zero buffers (e.g. constant encoded data) in which case this
        /// could be empty.
        #[prost(uint64, repeated, tag = "1")]
        pub buffer_offsets: ::prost::alloc::vec::Vec<u64>,
        /// The size (in bytes) of each of the page buffers
        ///
        /// This field will have the same length as `buffer_offsets` and
        /// may be empty.
        #[prost(uint64, repeated, tag = "2")]
        pub buffer_sizes: ::prost::alloc::vec::Vec<u64>,
        /// Logical length (e.g. # rows) of the page
        #[prost(uint64, tag = "3")]
        pub length: u64,
        /// The encoding used to encode the page
        #[prost(message, optional, tag = "4")]
        pub encoding: ::core::option::Option<super::Encoding>,
        /// The priority of the page
        ///
        /// For tabular data this will be the top-level row number of the first row
        /// in the page (and top-level rows should not split across pages).
        #[prost(uint64, tag = "5")]
        pub priority: u64,
    }
    impl ::prost::Name for Page {
        const NAME: &'static str = "Page";
        const PACKAGE: &'static str = "lance.file.v2";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.file.v2.ColumnMetadata.Page".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.file.v2.ColumnMetadata.Page".into()
        }
    }
}
impl ::prost::Name for ColumnMetadata {
    const NAME: &'static str = "ColumnMetadata";
    const PACKAGE: &'static str = "lance.file.v2";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.v2.ColumnMetadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.v2.ColumnMetadata".into()
    }
}
