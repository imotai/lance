// This file is @generated by prost-build.
/// A pointer to a buffer in a Lance file
///
/// A writer can place a buffer in three different locations.  The buffer
/// can go in the data page, in the column metadata, or in the file metadata.
/// The writer is free to choose whatever is most appropriate (for example, a dictionary
/// that is shared across all pages in a column will probably go in the column
/// metadata).  This specification does not dictate where the buffer should go.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Buffer {
    /// The index of the buffer in the collection of buffers
    #[prost(uint32, tag = "1")]
    pub buffer_index: u32,
    #[prost(enumeration = "buffer::BufferType", tag = "2")]
    pub buffer_type: i32,
}
/// Nested message and enum types in `Buffer`.
pub mod buffer {
    /// The collection holding the buffer
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BufferType {
        /// The buffer is stored in the data page itself
        Page = 0,
        /// The buffer is stored in the column metadata
        Column = 1,
        /// The buffer is stored in the file metadata
        File = 2,
    }
    impl BufferType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                BufferType::Page => "page",
                BufferType::Column => "column",
                BufferType::File => "file",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "page" => Some(Self::Page),
                "column" => Some(Self::Column),
                "file" => Some(Self::File),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Buffer {
    const NAME: &'static str = "Buffer";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Buffer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Buffer".into()
    }
}
/// An encoding that adds nullability to another array encoding
///
/// This can wrap any array encoding and add nullability information
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Nullable {
    #[prost(oneof = "nullable::Nullability", tags = "1, 2, 3")]
    pub nullability: ::core::option::Option<nullable::Nullability>,
}
/// Nested message and enum types in `Nullable`.
pub mod nullable {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct NoNull {
        #[prost(message, optional, boxed, tag = "1")]
        pub values: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::ArrayEncoding>,
        >,
    }
    impl ::prost::Name for NoNull {
        const NAME: &'static str = "NoNull";
        const PACKAGE: &'static str = "lance.encodings";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.encodings.Nullable.NoNull".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.encodings.Nullable.NoNull".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct AllNull {}
    impl ::prost::Name for AllNull {
        const NAME: &'static str = "AllNull";
        const PACKAGE: &'static str = "lance.encodings";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.encodings.Nullable.AllNull".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.encodings.Nullable.AllNull".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SomeNull {
        #[prost(message, optional, boxed, tag = "1")]
        pub validity: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::ArrayEncoding>,
        >,
        #[prost(message, optional, boxed, tag = "2")]
        pub values: ::core::option::Option<
            ::prost::alloc::boxed::Box<super::ArrayEncoding>,
        >,
    }
    impl ::prost::Name for SomeNull {
        const NAME: &'static str = "SomeNull";
        const PACKAGE: &'static str = "lance.encodings";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.encodings.Nullable.SomeNull".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.encodings.Nullable.SomeNull".into()
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Nullability {
        /// The array has no nulls and there is a single buffer needed
        #[prost(message, tag = "1")]
        NoNulls(::prost::alloc::boxed::Box<NoNull>),
        /// The array may have nulls and we need two buffers
        #[prost(message, tag = "2")]
        SomeNulls(::prost::alloc::boxed::Box<SomeNull>),
        /// All values are null (no buffers needed)
        #[prost(message, tag = "3")]
        AllNulls(AllNull),
    }
}
impl ::prost::Name for Nullable {
    const NAME: &'static str = "Nullable";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Nullable".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Nullable".into()
    }
}
/// An array encoding for variable-length list fields
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct List {
    /// An array containing the offsets into an items array.
    ///
    /// This array will have num_rows items and will never
    /// have nulls.
    ///
    /// If the list at index i is not null then offsets\[i\] will
    /// contain `base + len(list)` where `base` is defined as:
    ///    i == 0: 0
    ///    i >  0: (offsets\[i-1\] % null_offset_adjustment)
    ///
    /// To help understand we can consider the following example list:
    /// \[ [A, B\], null, \[\], \[C, D, E\] ]
    ///
    /// The offsets will be \[2, ?, 2, 5\]
    ///
    /// If the incoming list at index i IS null then offsets\[i\] will
    /// contain `base + len(list) + null_offset_adjustment` where `base`
    /// is defined the same as above.
    ///
    /// To complete the above example let's assume that `null_offset_adjustment`
    /// is 7.  Then the offsets will be \[2, 9, 2, 5\]
    ///
    /// If there are no nulls then the offsets we write here are exactly the
    /// same as the offsets in an Arrow list array (except we omit the leading
    /// 0 which is redundant)
    ///
    /// The reason we do this is so that reading a single list at index i only
    /// requires us to load the indices at i and i-1.
    ///
    /// If the offset at index i is greater than `null_offset_adjustment``
    /// then the list at index i is null.
    ///
    /// Otherwise the length of the list is `offsets\[i\] - base` where
    /// base is defined the same as above.
    ///
    /// Let's consider our example offsets: \[2, 9, 2, 5\]
    ///
    /// We can take any range of lists and determine how many list items are
    /// referenced by the sublist.
    ///
    /// 0..3: \[_, 5\] -> items 0..5 (base = 0* and end is 5)
    /// 0..2: \[_, 2\] -> items 0..2 (base = 0* and end is 2)
    /// 0..1: \[_, 9\] -> items 0..2 (base = 0* and end is 9 % 7)
    /// 1..3: \[2, 5\] -> items 2..5 (base = 2 and end is 5)
    /// 1..2: \[2, 2\] -> items 2..2 (base = 2 and end is 2)
    /// 2..3: \[9, 5\] -> items 2..5 (base = 9 % 7 and end is 5)
    ///
    /// * When the start of our range is the 0th item the base is always 0 and we only
    ///    need to load a single index from disk to determine the range.
    ///
    /// The data type of the offsets array is flexible and does not need
    /// to match the data type of the destination array.  Please note that the offsets
    /// array is very likely to be efficiently encoded by bit packing deltas.
    #[prost(message, optional, boxed, tag = "1")]
    pub offsets: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    /// If a list is null then we add this value to the offset
    ///
    /// This value must be greater than the length of the items so that
    /// (offset + null_offset_adjustment) is never used by a non-null list.
    ///
    /// Note that this value cannot be equal to the length of the items
    /// because then a page with a single list would store \[ X \] and we
    /// couldn't know if that is a null list or a list with X items.
    ///
    /// Therefore, the best choice for this value is 1 + # of items.
    /// Choosing this will maximize the bit packing that we can apply to the offsets.
    #[prost(uint64, tag = "2")]
    pub null_offset_adjustment: u64,
    /// How many items are referenced by these offsets.  This is needed in
    /// order to determine which items pages map to this offsets page.
    #[prost(uint64, tag = "3")]
    pub num_items: u64,
}
impl ::prost::Name for List {
    const NAME: &'static str = "List";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.List".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.List".into()
    }
}
/// An array encoding for fixed-size list fields
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixedSizeList {
    /// / The number of items in each list
    #[prost(uint32, tag = "1")]
    pub dimension: u32,
    /// / The items in the list
    #[prost(message, optional, boxed, tag = "2")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
}
impl ::prost::Name for FixedSizeList {
    const NAME: &'static str = "FixedSizeList";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.FixedSizeList".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.FixedSizeList".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Compression {
    #[prost(string, tag = "1")]
    pub scheme: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "2")]
    pub level: ::core::option::Option<i32>,
}
impl ::prost::Name for Compression {
    const NAME: &'static str = "Compression";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Compression".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Compression".into()
    }
}
/// Fixed width items placed contiguously in a buffer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flat {
    /// the number of bits per value, must be greater than 0, does
    /// not need to be a multiple of 8
    #[prost(uint64, tag = "1")]
    pub bits_per_value: u64,
    /// the buffer of values
    #[prost(message, optional, tag = "2")]
    pub buffer: ::core::option::Option<Buffer>,
    /// The Compression message can specify the compression scheme (e.g. zstd) and any
    /// other information that is needed for decompression.
    ///
    /// If this array is compressed then the bits_per_value refers to the uncompressed
    /// data.
    #[prost(message, optional, tag = "3")]
    pub compression: ::core::option::Option<Compression>,
}
impl ::prost::Name for Flat {
    const NAME: &'static str = "Flat";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Flat".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Flat".into()
    }
}
/// Compression algorithm where all values have a constant value
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Constant {
    /// The value (TODO: define encoding for literals?)
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    /// The number of values
    #[prost(uint64, tag = "2")]
    pub num_values: u64,
}
impl ::prost::Name for Constant {
    const NAME: &'static str = "Constant";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Constant".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Constant".into()
    }
}
/// Items are bitpacked in a buffer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bitpacked {
    /// the number of bits used for a value in the buffer
    #[prost(uint64, tag = "1")]
    pub compressed_bits_per_value: u64,
    /// the number of bits of the uncompressed value. e.g. for a u32, this will be 32
    #[prost(uint64, tag = "2")]
    pub uncompressed_bits_per_value: u64,
    /// The items in the list
    #[prost(message, optional, tag = "3")]
    pub buffer: ::core::option::Option<Buffer>,
    /// Whether or not a sign bit is included in the bitpacked value
    #[prost(bool, tag = "4")]
    pub signed: bool,
}
impl ::prost::Name for Bitpacked {
    const NAME: &'static str = "Bitpacked";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Bitpacked".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Bitpacked".into()
    }
}
/// Items are bitpacked in a buffer
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BitpackedForNonNeg {
    /// the number of bits used for a value in the buffer
    #[prost(uint64, tag = "1")]
    pub compressed_bits_per_value: u64,
    /// the number of bits of the uncompressed value. e.g. for a u32, this will be 32
    #[prost(uint64, tag = "2")]
    pub uncompressed_bits_per_value: u64,
    /// The items in the list
    #[prost(message, optional, tag = "3")]
    pub buffer: ::core::option::Option<Buffer>,
}
impl ::prost::Name for BitpackedForNonNeg {
    const NAME: &'static str = "BitpackedForNonNeg";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.BitpackedForNonNeg".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.BitpackedForNonNeg".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bitpack2 {
    /// the number of bits of the uncompressed value. e.g. for a u32, this will be 32
    #[prost(uint64, tag = "2")]
    pub uncompressed_bits_per_value: u64,
}
impl ::prost::Name for Bitpack2 {
    const NAME: &'static str = "Bitpack2";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Bitpack2".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Bitpack2".into()
    }
}
/// An array encoding for shredded structs that will never be null
///
/// There is no actual data in this column.
///
/// TODO: Struct validity bitmaps will be placed here.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SimpleStruct {}
impl ::prost::Name for SimpleStruct {
    const NAME: &'static str = "SimpleStruct";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.SimpleStruct".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.SimpleStruct".into()
    }
}
/// An array encoding for binary fields
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Binary {
    #[prost(message, optional, boxed, tag = "1")]
    pub indices: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub bytes: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    #[prost(uint64, tag = "3")]
    pub null_adjustment: u64,
}
impl ::prost::Name for Binary {
    const NAME: &'static str = "Binary";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Binary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Binary".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Fsst {
    #[prost(message, optional, boxed, tag = "1")]
    pub binary: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    #[prost(bytes = "vec", tag = "2")]
    pub symbol_table: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for Fsst {
    const NAME: &'static str = "Fsst";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Fsst".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Fsst".into()
    }
}
/// An array encoding for dictionary-encoded fields
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dictionary {
    #[prost(message, optional, boxed, tag = "1")]
    pub indices: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    #[prost(message, optional, boxed, tag = "2")]
    pub items: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    #[prost(uint32, tag = "3")]
    pub num_dictionary_items: u32,
}
impl ::prost::Name for Dictionary {
    const NAME: &'static str = "Dictionary";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Dictionary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Dictionary".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PackedStruct {
    #[prost(message, repeated, tag = "1")]
    pub inner: ::prost::alloc::vec::Vec<ArrayEncoding>,
    #[prost(message, optional, tag = "2")]
    pub buffer: ::core::option::Option<Buffer>,
}
impl ::prost::Name for PackedStruct {
    const NAME: &'static str = "PackedStruct";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.PackedStruct".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.PackedStruct".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FixedSizeBinary {
    #[prost(message, optional, boxed, tag = "1")]
    pub bytes: ::core::option::Option<::prost::alloc::boxed::Box<ArrayEncoding>>,
    #[prost(uint32, tag = "2")]
    pub byte_width: u32,
}
impl ::prost::Name for FixedSizeBinary {
    const NAME: &'static str = "FixedSizeBinary";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.FixedSizeBinary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.FixedSizeBinary".into()
    }
}
/// Encodings that decode into an Arrow array
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArrayEncoding {
    #[prost(
        oneof = "array_encoding::ArrayEncoding",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14"
    )]
    pub array_encoding: ::core::option::Option<array_encoding::ArrayEncoding>,
}
/// Nested message and enum types in `ArrayEncoding`.
pub mod array_encoding {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ArrayEncoding {
        #[prost(message, tag = "1")]
        Flat(super::Flat),
        #[prost(message, tag = "2")]
        Nullable(::prost::alloc::boxed::Box<super::Nullable>),
        #[prost(message, tag = "3")]
        FixedSizeList(::prost::alloc::boxed::Box<super::FixedSizeList>),
        #[prost(message, tag = "4")]
        List(::prost::alloc::boxed::Box<super::List>),
        #[prost(message, tag = "5")]
        Struct(super::SimpleStruct),
        #[prost(message, tag = "6")]
        Binary(::prost::alloc::boxed::Box<super::Binary>),
        #[prost(message, tag = "7")]
        Dictionary(::prost::alloc::boxed::Box<super::Dictionary>),
        #[prost(message, tag = "8")]
        Fsst(::prost::alloc::boxed::Box<super::Fsst>),
        #[prost(message, tag = "9")]
        PackedStruct(super::PackedStruct),
        #[prost(message, tag = "10")]
        Bitpacked(super::Bitpacked),
        #[prost(message, tag = "11")]
        FixedSizeBinary(::prost::alloc::boxed::Box<super::FixedSizeBinary>),
        #[prost(message, tag = "12")]
        BitpackedForNonNeg(super::BitpackedForNonNeg),
        #[prost(message, tag = "13")]
        Constant(super::Constant),
        #[prost(message, tag = "14")]
        Bitpack2(super::Bitpack2),
    }
}
impl ::prost::Name for ArrayEncoding {
    const NAME: &'static str = "ArrayEncoding";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.ArrayEncoding".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.ArrayEncoding".into()
    }
}
/// Wraps a column with a zone map index that can be used
/// to apply pushdown filters
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ZoneIndex {
    #[prost(uint32, tag = "1")]
    pub rows_per_zone: u32,
    #[prost(message, optional, tag = "2")]
    pub zone_map_buffer: ::core::option::Option<Buffer>,
    #[prost(message, optional, boxed, tag = "3")]
    pub inner: ::core::option::Option<::prost::alloc::boxed::Box<ColumnEncoding>>,
}
impl ::prost::Name for ZoneIndex {
    const NAME: &'static str = "ZoneIndex";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.ZoneIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.ZoneIndex".into()
    }
}
/// Marks a column as blob data.  It will contain a packed struct
/// with fields position and size (u64)
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Blob {
    #[prost(message, optional, boxed, tag = "1")]
    pub inner: ::core::option::Option<::prost::alloc::boxed::Box<ColumnEncoding>>,
}
impl ::prost::Name for Blob {
    const NAME: &'static str = "Blob";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.Blob".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.Blob".into()
    }
}
/// Encodings that describe a column of values
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnEncoding {
    #[prost(oneof = "column_encoding::ColumnEncoding", tags = "1, 2, 3")]
    pub column_encoding: ::core::option::Option<column_encoding::ColumnEncoding>,
}
/// Nested message and enum types in `ColumnEncoding`.
pub mod column_encoding {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ColumnEncoding {
        /// No special encoding, just column values
        #[prost(message, tag = "1")]
        Values(()),
        #[prost(message, tag = "2")]
        ZoneIndex(::prost::alloc::boxed::Box<super::ZoneIndex>),
        #[prost(message, tag = "3")]
        Blob(::prost::alloc::boxed::Box<super::Blob>),
    }
}
impl ::prost::Name for ColumnEncoding {
    const NAME: &'static str = "ColumnEncoding";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.ColumnEncoding".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.ColumnEncoding".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MiniBlockLayout {
    /// Description of the compression of repetition levels (e.g. how many bits per rep)
    #[prost(message, optional, tag = "1")]
    pub rep_compression: ::core::option::Option<ArrayEncoding>,
    /// Description of the compression of definition levels (e.g. how many bits per def)
    #[prost(message, optional, tag = "2")]
    pub def_compression: ::core::option::Option<ArrayEncoding>,
    /// Description of the compression of values
    #[prost(message, optional, tag = "3")]
    pub value_compression: ::core::option::Option<ArrayEncoding>,
}
impl ::prost::Name for MiniBlockLayout {
    const NAME: &'static str = "MiniBlockLayout";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.MiniBlockLayout".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.MiniBlockLayout".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AllNullLayout {}
impl ::prost::Name for AllNullLayout {
    const NAME: &'static str = "AllNullLayout";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.AllNullLayout".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.AllNullLayout".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PageLayout {
    #[prost(oneof = "page_layout::Layout", tags = "1, 2")]
    pub layout: ::core::option::Option<page_layout::Layout>,
}
/// Nested message and enum types in `PageLayout`.
pub mod page_layout {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Layout {
        #[prost(message, tag = "1")]
        MiniBlockLayout(super::MiniBlockLayout),
        #[prost(message, tag = "2")]
        AllNullLayout(super::AllNullLayout),
    }
}
impl ::prost::Name for PageLayout {
    const NAME: &'static str = "PageLayout";
    const PACKAGE: &'static str = "lance.encodings";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.encodings.PageLayout".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.encodings.PageLayout".into()
    }
}
