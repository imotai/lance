// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Index {
    /// The unique index name in the dataset.
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Columns to be used to build the index.
    #[prost(string, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The version of the dataset this index was built from.
    #[prost(uint64, tag = "3")]
    pub dataset_version: u64,
    /// The \[`IndexType`\] of the index.
    #[prost(enumeration = "IndexType", tag = "4")]
    pub index_type: i32,
    /// / Index implementation details.
    #[prost(oneof = "index::Implementation", tags = "5")]
    pub implementation: ::core::option::Option<index::Implementation>,
}
/// Nested message and enum types in `Index`.
pub mod index {
    /// / Index implementation details.
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Implementation {
        #[prost(message, tag = "5")]
        VectorIndex(super::VectorIndex),
    }
}
impl ::prost::Name for Index {
    const NAME: &'static str = "Index";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.Index".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.Index".into()
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Tensor {
    #[prost(enumeration = "tensor::DataType", tag = "1")]
    pub data_type: i32,
    /// Data shape, \[dim1, dim2, ...\]
    #[prost(uint32, repeated, tag = "2")]
    pub shape: ::prost::alloc::vec::Vec<u32>,
    /// Data buffer
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// Nested message and enum types in `Tensor`.
pub mod tensor {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum DataType {
        Bfloat16 = 0,
        Float16 = 1,
        Float32 = 2,
        Float64 = 3,
        Uint8 = 4,
        Uint16 = 5,
        Uint32 = 6,
        Uint64 = 7,
    }
    impl DataType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                DataType::Bfloat16 => "BFLOAT16",
                DataType::Float16 => "FLOAT16",
                DataType::Float32 => "FLOAT32",
                DataType::Float64 => "FLOAT64",
                DataType::Uint8 => "UINT8",
                DataType::Uint16 => "UINT16",
                DataType::Uint32 => "UINT32",
                DataType::Uint64 => "UINT64",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BFLOAT16" => Some(Self::Bfloat16),
                "FLOAT16" => Some(Self::Float16),
                "FLOAT32" => Some(Self::Float32),
                "FLOAT64" => Some(Self::Float64),
                "UINT8" => Some(Self::Uint8),
                "UINT16" => Some(Self::Uint16),
                "UINT32" => Some(Self::Uint32),
                "UINT64" => Some(Self::Uint64),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Tensor {
    const NAME: &'static str = "Tensor";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.Tensor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.Tensor".into()
    }
}
/// Inverted Index File Metadata.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Ivf {
    /// Centroids of partitions. `dimension * num_partitions` of float32s.
    ///
    /// Deprecated, use centroids_tensor instead.
    ///
    /// \[deprecated = true\];
    #[prost(float, repeated, tag = "1")]
    pub centroids: ::prost::alloc::vec::Vec<f32>,
    /// File offset of each partition.
    #[prost(uint64, repeated, tag = "2")]
    pub offsets: ::prost::alloc::vec::Vec<u64>,
    /// Number of records in the partition.
    #[prost(uint32, repeated, tag = "3")]
    pub lengths: ::prost::alloc::vec::Vec<u32>,
    /// Tensor of centroids. `num_partitions * dimension` of float32s.
    #[prost(message, optional, tag = "4")]
    pub centroids_tensor: ::core::option::Option<Tensor>,
}
impl ::prost::Name for Ivf {
    const NAME: &'static str = "IVF";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.IVF".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.IVF".into()
    }
}
/// Product Quantization.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Pq {
    /// The number of bits to present a centroid.
    #[prost(uint32, tag = "1")]
    pub num_bits: u32,
    /// Number of sub vectors.
    #[prost(uint32, tag = "2")]
    pub num_sub_vectors: u32,
    /// Vector dimension
    #[prost(uint32, tag = "3")]
    pub dimension: u32,
    /// Codebook. `dimension * 2 ^ num_bits` of float32s.
    #[prost(float, repeated, tag = "4")]
    pub codebook: ::prost::alloc::vec::Vec<f32>,
    /// Tensor of codebook. `2 ^ num_bits * dimension` of floats.
    #[prost(message, optional, tag = "5")]
    pub codebook_tensor: ::core::option::Option<Tensor>,
}
impl ::prost::Name for Pq {
    const NAME: &'static str = "PQ";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.PQ".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.PQ".into()
    }
}
/// A transform matrix to apply to a vector or vectors.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Transform {
    /// The file offset the matrix is stored
    #[prost(uint64, tag = "1")]
    pub position: u64,
    /// Data shape of the matrix, \[rows, cols\].
    #[prost(uint32, repeated, tag = "2")]
    pub shape: ::prost::alloc::vec::Vec<u32>,
    /// Transform type.
    #[prost(enumeration = "TransformType", tag = "3")]
    pub r#type: i32,
}
impl ::prost::Name for Transform {
    const NAME: &'static str = "Transform";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.Transform".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.Transform".into()
    }
}
/// Flat Index
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Flat {}
impl ::prost::Name for Flat {
    const NAME: &'static str = "Flat";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.Flat".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.Flat".into()
    }
}
/// DiskAnn Index
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DiskAnn {
    /// Graph spec version
    #[prost(uint32, tag = "1")]
    pub spec: u32,
    /// Graph file
    #[prost(string, tag = "2")]
    pub filename: ::prost::alloc::string::String,
    /// r parameter
    #[prost(uint32, tag = "3")]
    pub r: u32,
    /// alpha parameter
    #[prost(float, tag = "4")]
    pub alpha: f32,
    /// L parameter
    #[prost(uint32, tag = "5")]
    pub l: u32,
    /// / Entry points to the graph
    #[prost(uint64, repeated, tag = "6")]
    pub entries: ::prost::alloc::vec::Vec<u64>,
}
impl ::prost::Name for DiskAnn {
    const NAME: &'static str = "DiskAnn";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.DiskAnn".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.DiskAnn".into()
    }
}
/// One stage in the vector index pipeline.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorIndexStage {
    #[prost(oneof = "vector_index_stage::Stage", tags = "1, 2, 3, 4, 5")]
    pub stage: ::core::option::Option<vector_index_stage::Stage>,
}
/// Nested message and enum types in `VectorIndexStage`.
pub mod vector_index_stage {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Stage {
        /// Flat index
        #[prost(message, tag = "1")]
        Flat(super::Flat),
        /// `IVF` - Inverted File
        #[prost(message, tag = "2")]
        Ivf(super::Ivf),
        /// Product Quantization
        #[prost(message, tag = "3")]
        Pq(super::Pq),
        /// Transformer
        #[prost(message, tag = "4")]
        Transform(super::Transform),
        /// DiskANN
        #[prost(message, tag = "5")]
        Diskann(super::DiskAnn),
    }
}
impl ::prost::Name for VectorIndexStage {
    const NAME: &'static str = "VectorIndexStage";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.VectorIndexStage".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.VectorIndexStage".into()
    }
}
/// Vector Index Metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VectorIndex {
    /// Index specification version.
    #[prost(uint32, tag = "1")]
    pub spec_version: u32,
    /// Vector dimension;
    #[prost(uint32, tag = "2")]
    pub dimension: u32,
    /// Composed vector index stages.
    ///
    /// For example, `IVF_PQ` index type can be expressed as:
    ///
    /// ```no_run,ignore
    /// let stages = vec!\[Ivf{}, PQ{num_bits: 8, num_sub_vectors: 16}\]
    /// ```
    #[prost(message, repeated, tag = "3")]
    pub stages: ::prost::alloc::vec::Vec<VectorIndexStage>,
    /// Vector distance metrics type
    #[prost(enumeration = "VectorMetricType", tag = "4")]
    pub metric_type: i32,
}
impl ::prost::Name for VectorIndex {
    const NAME: &'static str = "VectorIndex";
    const PACKAGE: &'static str = "lance.index.pb";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.index.pb.VectorIndex".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.index.pb.VectorIndex".into()
    }
}
/// The type of an index.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum IndexType {
    /// Vector index
    Vector = 0,
}
impl IndexType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            IndexType::Vector => "VECTOR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "VECTOR" => Some(Self::Vector),
            _ => None,
        }
    }
}
/// Transform type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum TransformType {
    Opq = 0,
}
impl TransformType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            TransformType::Opq => "OPQ",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OPQ" => Some(Self::Opq),
            _ => None,
        }
    }
}
/// Metric Type for Vector Index
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum VectorMetricType {
    /// L2 (Euclidean) Distance
    L2 = 0,
    /// Cosine Distance
    Cosine = 1,
    /// Dot Product
    Dot = 2,
    /// Hamming Distance
    Hamming = 3,
}
impl VectorMetricType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            VectorMetricType::L2 => "L2",
            VectorMetricType::Cosine => "Cosine",
            VectorMetricType::Dot => "Dot",
            VectorMetricType::Hamming => "Hamming",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "L2" => Some(Self::L2),
            "Cosine" => Some(Self::Cosine),
            "Dot" => Some(Self::Dot),
            "Hamming" => Some(Self::Hamming),
            _ => None,
        }
    }
}
