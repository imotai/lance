// This file is @generated by prost-build.
/// A file descriptor that describes the contents of a Lance file
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileDescriptor {
    /// The schema of the file
    #[prost(message, optional, tag = "1")]
    pub schema: ::core::option::Option<Schema>,
    /// The number of rows in the file
    #[prost(uint64, tag = "2")]
    pub length: u64,
}
impl ::prost::Name for FileDescriptor {
    const NAME: &'static str = "FileDescriptor";
    const PACKAGE: &'static str = "lance.file";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.FileDescriptor".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.FileDescriptor".into()
    }
}
/// A schema which describes the data type of each of the columns
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Schema {
    /// All fields in this file, including the nested fields.
    #[prost(message, repeated, tag = "1")]
    pub fields: ::prost::alloc::vec::Vec<Field>,
    /// Schema metadata.
    #[prost(map = "string, bytes", tag = "5")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
impl ::prost::Name for Schema {
    const NAME: &'static str = "Schema";
    const PACKAGE: &'static str = "lance.file";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.Schema".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.Schema".into()
    }
}
/// Metadata of one Lance file.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Metadata {
    /// Position of the manifest in the file. If it is zero, the manifest is stored
    /// externally.
    #[prost(uint64, tag = "1")]
    pub manifest_position: u64,
    /// Logical offsets of each chunk group, i.e., number of the rows in each
    /// chunk.
    #[prost(int32, repeated, tag = "2")]
    pub batch_offsets: ::prost::alloc::vec::Vec<i32>,
    /// The file position that page table is stored.
    ///
    /// A page table is a matrix of N x M x 2, where N = num_fields, and M =
    /// num_batches. Each cell in the table is a pair of <position:int64,
    /// length:int64> of the page. Both position and length are int64 values. The
    /// <position, length> of all the pages in the same column are then
    /// contiguously stored.
    ///
    /// Every field that is a part of the file will have a run in the page table.
    /// This includes struct columns, which will have a run of length 0 since
    /// they don't store any actual data.
    ///
    /// For example, for the column 5 and batch 4, we have:
    /// ```text
    ///    position = page_table[5][4][0];
    ///    length = page_table[5][4][1];
    /// ```
    #[prost(uint64, tag = "3")]
    pub page_table_position: u64,
    #[prost(message, optional, tag = "5")]
    pub statistics: ::core::option::Option<metadata::StatisticsMetadata>,
}
/// Nested message and enum types in `Metadata`.
pub mod metadata {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct StatisticsMetadata {
        /// The schema of the statistics.
        ///
        /// This might be empty, meaning there are no statistics. It also might not
        /// contain statistics for every field.
        #[prost(message, repeated, tag = "1")]
        pub schema: ::prost::alloc::vec::Vec<super::Field>,
        /// The field ids of the statistics leaf fields.
        ///
        /// This plays a similar role to the `fields` field in the DataFile message.
        /// Each of these field ids corresponds to a field in the stats_schema. There
        /// is one per column in the stats page table.
        #[prost(int32, repeated, tag = "2")]
        pub fields: ::prost::alloc::vec::Vec<i32>,
        /// The file position of the statistics page table
        ///
        /// The page table is a matrix of N x 2, where N = length of stats_fields. This is
        /// the same layout as the main page table, except there is always only one
        /// batch.
        ///
        /// For example, to get the stats column 5, we have:
        /// ```text
        ///    position = stats_page_table[5][0];
        ///    length = stats_page_table[5][1];
        /// ```
        #[prost(uint64, tag = "3")]
        pub page_table_position: u64,
    }
    impl ::prost::Name for StatisticsMetadata {
        const NAME: &'static str = "StatisticsMetadata";
        const PACKAGE: &'static str = "lance.file";
        fn full_name() -> ::prost::alloc::string::String {
            "lance.file.Metadata.StatisticsMetadata".into()
        }
        fn type_url() -> ::prost::alloc::string::String {
            "/lance.file.Metadata.StatisticsMetadata".into()
        }
    }
}
impl ::prost::Name for Metadata {
    const NAME: &'static str = "Metadata";
    const PACKAGE: &'static str = "lance.file";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.Metadata".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.Metadata".into()
    }
}
/// Dictionary field metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Dictionary {
    /// / The file offset for storing the dictionary value.
    /// / It is only valid if encoding is DICTIONARY.
    /// /
    /// / The logic type presents the value type of the column, i.e., string value.
    #[prost(int64, tag = "1")]
    pub offset: i64,
    /// / The length of dictionary values.
    #[prost(int64, tag = "2")]
    pub length: i64,
}
impl ::prost::Name for Dictionary {
    const NAME: &'static str = "Dictionary";
    const PACKAGE: &'static str = "lance.file";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.Dictionary".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.Dictionary".into()
    }
}
/// Field metadata for a column.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(enumeration = "field::Type", tag = "1")]
    pub r#type: i32,
    /// Fully qualified name.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// / Field Id.
    /// /
    /// / See the comment in `DataFile.fields` for how field ids are assigned.
    #[prost(int32, tag = "3")]
    pub id: i32,
    /// / Parent Field ID. If not set, this is a top-level column.
    #[prost(int32, tag = "4")]
    pub parent_id: i32,
    /// Logical types, support parameterized Arrow Type.
    ///
    /// PARENT types will always have logical type "struct".
    ///
    /// REPEATED types may have logical types:
    /// * "list"
    /// * "large_list"
    /// * "list.struct"
    /// * "large_list.struct"
    /// The final two are used if the list values are structs, and therefore the
    /// field is both implicitly REPEATED and PARENT.
    ///
    /// LEAF types may have logical types:
    /// * "null"
    /// * "bool"
    /// * "int8" / "uint8"
    /// * "int16" / "uint16"
    /// * "int32" / "uint32"
    /// * "int64" / "uint64"
    /// * "halffloat" / "float" / "double"
    /// * "string" / "large_string"
    /// * "binary" / "large_binary"
    /// * "date32:day"
    /// * "date64:ms"
    /// * "decimal:128:{precision}:{scale}" / "decimal:256:{precision}:{scale}"
    /// * "time:{unit}" / "timestamp:{unit}" / "duration:{unit}", where unit is "s", "ms", "us", "ns"
    /// * "dict:{value_type}:{index_type}:false"
    #[prost(string, tag = "5")]
    pub logical_type: ::prost::alloc::string::String,
    /// If this field is nullable.
    #[prost(bool, tag = "6")]
    pub nullable: bool,
    #[prost(enumeration = "Encoding", tag = "7")]
    pub encoding: i32,
    /// / The file offset for storing the dictionary value.
    /// / It is only valid if encoding is DICTIONARY.
    /// /
    /// / The logic type presents the value type of the column, i.e., string value.
    #[prost(message, optional, tag = "8")]
    pub dictionary: ::core::option::Option<Dictionary>,
    /// Deprecated: optional extension type name, use metadata field ARROW:extension:name
    #[prost(string, tag = "9")]
    pub extension_name: ::prost::alloc::string::String,
    /// optional field metadata (e.g. extension type name/parameters)
    #[prost(map = "string, bytes", tag = "10")]
    pub metadata: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
/// Nested message and enum types in `Field`.
pub mod field {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Parent = 0,
        Repeated = 1,
        Leaf = 2,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Type::Parent => "PARENT",
                Type::Repeated => "REPEATED",
                Type::Leaf => "LEAF",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "PARENT" => Some(Self::Parent),
                "REPEATED" => Some(Self::Repeated),
                "LEAF" => Some(Self::Leaf),
                _ => None,
            }
        }
    }
}
impl ::prost::Name for Field {
    const NAME: &'static str = "Field";
    const PACKAGE: &'static str = "lance.file";
    fn full_name() -> ::prost::alloc::string::String {
        "lance.file.Field".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/lance.file.Field".into()
    }
}
/// Supported encodings.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Encoding {
    /// Invalid encoding.
    None = 0,
    /// Plain encoding.
    Plain = 1,
    /// Var-length binary encoding.
    VarBinary = 2,
    /// Dictionary encoding.
    Dictionary = 3,
    /// Run-length encoding.
    Rle = 4,
}
impl Encoding {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Encoding::None => "NONE",
            Encoding::Plain => "PLAIN",
            Encoding::VarBinary => "VAR_BINARY",
            Encoding::Dictionary => "DICTIONARY",
            Encoding::Rle => "RLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NONE" => Some(Self::None),
            "PLAIN" => Some(Self::Plain),
            "VAR_BINARY" => Some(Self::VarBinary),
            "DICTIONARY" => Some(Self::Dictionary),
            "RLE" => Some(Self::Rle),
            _ => None,
        }
    }
}
